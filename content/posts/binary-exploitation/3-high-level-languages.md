---
title: "Binary Exploitation 3: High-level languages"
date: 2023-06-16T00:00:00+02:00
draft: false
tags:
  - binary exploitation
---

While programming in low-level languages provides fine-grained control and direct interaction with the hardware, it comes with challenges such as complex syntax, complex debugging and a steep learning curve. High-level languages strike a balance between abstraction and control, allowing developers to focus on the problem domain and benefit from a more efficient and enjoyable development experience. High-level languages are designed to be platform-independent. Code written in a high-level language can be compiled and executed on different platforms with minimal or no modifications. This portability saves time and effort, as developers do not have to rewrite the entire codebase for each target platform.

## Programming in C language

When we talk about high-level languages, we talk about programming in C, as we want to stay close to low-level languages. Example of program in C is below.

```C
#include<stdio.h>

int main()
{
  printf("Hello, world!\n");
  return 0;
}
```

The source code must be then compiled to machine code using a compiler. Some of them are:
- gcc (GNU compiler)
- clang (Apple)
- Microsoft compiler for Visual C++ (Microsoft)

If we have source code saved in file `main.c` we can compile it using `gcc` with one simple command:
```
$ gcc -o main main.c
```
The result is binary file named `main` with machine code in it. If we check magic bytes using `file` command we see that the file is in ELF format and compiled for x64 architecture. ELF is the standard file format for executables in Linux.

```
$ file main
main: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, 
interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, not stripped
```

### Cross compiling
In case we would like to run a program on some other platforms, we would need to compile it again and target specific operating system and architecture.

For ELF in x86 architecture we can compile with the following command and because the x64 is backward compatible with x86 we can also run compiled program on our x64 processor.
```
$ sudo apt-get install gcc-multilib
$ gcc -m32 -o main32 main.c
```

Now the magic bytes at the beginning of the file look different.
```
$ file main32
main32: ELF 32-bit LSB pie executable, Intel 80386, version 1 (SYSV), dynamically linked, 
interpreter /lib/ld-linux.so.2, for GNU/Linux 3.2.0, not stripped
```

### Machine code and assembly
We can inspect generated machine and assembly code using `objdump` tool. With flag `-M intel` we force Intel assembly sintax.

```
$ objdump -S main -M intel 

main:     file format elf64-x86-64

...
0000000000001139 <main>:
    1139:       55                      push   rbp
    113a:       48 89 e5                mov    rbp,rsp
    113d:       48 8d 05 c0 0e 00 00    lea    rax,[rip+0xec0]        # 2004 <_IO_stdin_used+0x4>
    1144:       48 89 c7                mov    rdi,rax
    1147:       e8 e4 fe ff ff          call   1030 <puts@plt>
    114c:       b8 00 00 00 00          mov    eax,0x0
    1151:       5d                      pop    rbp
    1152:       c3                      ret
...                                        
```

### Reverse engineering
It is important to note that it is impossible to reconstruct original source code from compiled code, but we can get close with tools like `Ghidra`.

```
$ sudo apt install ghidra
$ ghidra
```

In Ghidra create new project and then import compiled binary file in it as ELF file, it will automatically detect architecture and used compiler. After that open file in CodeBrowser and analyze it (keep default settings).

Under Symbol Tree expand Functions and find function main. Click on it and it will get displayed in C like format in Decompile view. 
```
undefined8 main(void)
{
  puts("Hello, world!");
  return 0;
}
```

Decompiled code can be made more bearable with:
- adding comments
- editing function signatures
- renaming variables
- changing types of variables

The code we get is an approximation of the original source code as we cannot reconstruct all the details.